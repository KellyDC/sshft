name: "Secure File Transfer"
description: "A GitHub Action to securely transfer files over SSH using SCP with support for upload and download directions."
author: "KellyDC"
inputs:
  host:
    description: "SSH host to connect to"
    required: true
  port:
    description: "SSH port"
    required: false
    default: "22"
  username:
    description: "SSH username"
    required: true
  key:
    description: "SSH private key"
    required: true
  passphrase:
    description: "Passphrase for the SSH private key"
    required: false
  source:
    description: "Source file or directory to transfer"
    required: true
  destination:
    description: "Destination path on the target server"
    required: true
  direction:
    description: "Transfer direction"
    required: false
    default: "upload"
  recursive:
    description: "Transfer files recursively"
    required: false
    default: "true"
  strict_host_key_checking:
    description: "Enable strict host key checking"
    required: false
    default: "true"
  post_script:
    description: "Optional inline script to run on the target server after file transfer completes"
    required: false
  post_script_path:
    description: "Optional path to a script on the target server to run after file transfer completes"
    required: false
  backup_before_transfer:
    description: "Create a backup of the destination before transferring files"
    required: false
    default: "true"
outputs:
  success:
    description: "File transfer was successful"
    value: ${{ steps.transfer.outputs.success }}
  backup_created:
    description: "Whether a backup was created"
    value: ${{ steps.backup.outputs.created }}
  backup_path:
    description: "Path to the backup file on the remote server"
    value: ${{ steps.backup.outputs.path }}
  backup_size:
    description: "Size of the backup file"
    value: ${{ steps.backup.outputs.size }}
  error:
    description: "An error occurred during file transfer"
    value: ${{ steps.transfer.outputs.error }}
  script_executed:
    description: "Whether a post-transfer script was executed"
    value: ${{ steps.post_script.outputs.executed }}
  script_output:
    description: "Output from the post-transfer script execution"
    value: ${{ steps.post_script.outputs.output }}
  script_error:
    description: "Error message if script execution failed"
    value: ${{ steps.post_script.outputs.error }}

runs:
  using: "composite"
  steps:
    - name: Setup SSH key and configuration
      shell: bash
      run: |
        # This ensures that the action stops if any part of it encounters an error
        set -e
        # Create SSH directory with correct permissions
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh

        # Generate a unique key filename to avoid conflicts with existing keys
        SSH_KEY_FILE="$HOME/.ssh/sshft_key_$(date +%s)_$RANDOM"
        SSH_CONFIG_FILE="$HOME/.ssh/sshft_config_$(date +%s)_$RANDOM"
        SSH_KNOWN_HOSTS="$HOME/.ssh/sshft_known_hosts_$(date +%s)_$RANDOM"

        # Export the key path for other steps to use
        echo "SSH_KEY_FILE=$SSH_KEY_FILE" >> $GITHUB_ENV
        echo "SSH_CONFIG_FILE=$SSH_CONFIG_FILE" >> $GITHUB_ENV
        echo "SSH_KNOWN_HOSTS=$SSH_KNOWN_HOSTS" >> $GITHUB_ENV

        # Save SSH key with proper permissions (before writing content)
        touch "$SSH_KEY_FILE"
        chmod 600 "$SSH_KEY_FILE"
        echo "${{ inputs.key }}" > "$SSH_KEY_FILE"

        # Verify the key is valid
        if ! ssh-keygen -l -f "$SSH_KEY_FILE" &>/dev/null; then
          echo "Error: The provided SSH key appears to be invalid"
          rm -f "$SSH_KEY_FILE"
          exit 1
        fi

        # Create SSH config with appropriate security settings
        printf "Host %s\nPort %s\nUser %s\nIdentityFile %s\nBatchMode yes\nConnectTimeout 30\nServerAliveInterval 60\nServerAliveCountMax 10\n" "${{ inputs.host }}" "${{ inputs.port }}" "${{ inputs.username }}" "$SSH_KEY_FILE" > "$SSH_CONFIG_FILE"

        # Configure host key checking based on input
        if [ "${{ inputs.strict_host_key_checking }}" = "false" ]; then
          echo "  StrictHostKeyChecking no" >> "$SSH_CONFIG_FILE"
          echo "  UserKnownHostsFile=/dev/null" >> "$SSH_CONFIG_FILE"
        else
          # First try to scan the host key
          touch "$SSH_KNOWN_HOSTS"
          chmod 600 "$SSH_KNOWN_HOSTS"
          ssh-keyscan -p ${{ inputs.port }} -H ${{ inputs.host }} >> "$SSH_KNOWN_HOSTS" 2>/dev/null || true
          echo "  StrictHostKeyChecking yes" >> "$SSH_CONFIG_FILE"
          echo "  UserKnownHostsFile=$SSH_KNOWN_HOSTS" >> "$SSH_CONFIG_FILE"
        fi

        chmod 600 "$SSH_CONFIG_FILE"

        # Handle SSH key passphrase if provided
        if [ -n "${{ inputs.passphrase }}" ]; then
          eval $(ssh-agent -s)
          echo "${{ inputs.passphrase }}" | ssh-add "$SSH_KEY_FILE"
        fi

    - name: Verify SSH connection
      shell: bash
      run: |
        if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "echo SSH connection successful"; then
          echo "Error: Failed to establish SSH connection"
          exit 1
        fi

    - name: Backup destination before transfer
      shell: bash
      id: backup
      if: inputs.backup_before_transfer == 'true' && inputs.direction == 'upload'
      run: |
        set -e
        echo "created=false" >> $GITHUB_OUTPUT
        echo "path=" >> $GITHUB_OUTPUT
        echo "size=" >> $GITHUB_OUTPUT

        echo "Starting backup process..."

        # Generate timestamp and random ID for unique backup filename
        BACKUP_TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        RANDOM_ID=$(openssl rand -hex 4)

        # Get destination basename for backup filename
        DEST_PATH="${{ inputs.destination }}"
        if [[ "$DEST_PATH" == */ ]]; then
          DEST_PATH="${DEST_PATH%/}"
        fi
        DEST_BASENAME=$(basename "$DEST_PATH")

        # Create backup filename with timestamp
        BACKUP_FILENAME="backup_${DEST_BASENAME}_${BACKUP_TIMESTAMP}_${RANDOM_ID}.tar.gz"
        BACKUP_DIR="$HOME/backups"
        BACKUP_PATH="$BACKUP_DIR/$BACKUP_FILENAME"

        # Check if destination exists on remote server
        DEST_EXISTS=$(ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "
          if [ -e \"$DEST_PATH\" ]; then
            echo 'exists'
          else
            echo 'not_exists'
          fi
        " 2>&1) || {
          echo "Error: Failed to check if destination exists"
          exit 1
        }

        if [ "$DEST_EXISTS" = "not_exists" ]; then
          echo "Destination does not exist yet, no backup needed"
          echo "Note: This is the first transfer to this destination"
          exit 0
        fi

        echo "Destination exists, creating backup..."

        # Create backup directory on remote server if it doesn't exist
        if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "
          set -e
          if [ ! -d \"$BACKUP_DIR\" ]; then
            mkdir -p \"$BACKUP_DIR\" && echo 'Backup directory created at: $BACKUP_DIR'
            chmod 700 \"$BACKUP_DIR\"
          else
            echo 'Using existing backup directory: $BACKUP_DIR'
          fi
          
          # Verify backup directory is writable
          if [ ! -w \"$BACKUP_DIR\" ]; then
            echo 'Error: Backup directory is not writable'
            exit 1
          fi
        " 2>&1; then
          echo "Error: Failed to create or verify backup directory"
          exit 1
        fi

        # Create backup using tar.gz with error handling
        echo "Compressing destination to backup file..."
        BACKUP_OUTPUT=$(ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "
          set -e
          
          # Get parent directory and basename for tar
          DEST_PARENT=\$(dirname \"$DEST_PATH\")
          DEST_BASE=\$(basename \"$DEST_PATH\")
          
          # Create the backup with compression
          if tar -czf \"$BACKUP_PATH\" -C \"\$DEST_PARENT\" \"\$DEST_BASE\" 2>&1; then
            # Verify the backup was created successfully
            if [ ! -f \"$BACKUP_PATH\" ]; then
              echo 'Error: Backup file was not created'
              exit 1
            fi
            
            # Get backup file size
            BACKUP_SIZE=\$(du -h \"$BACKUP_PATH\" | cut -f1)
            echo \"Backup created successfully: $BACKUP_PATH\"
            echo \"Backup size: \$BACKUP_SIZE\"
            echo \"SIZE:\$BACKUP_SIZE\"
          else
            echo 'Error: Failed to create backup archive'
            exit 1
          fi
        " 2>&1) || {
          echo "Error during backup creation:"
          echo "$BACKUP_OUTPUT"
          exit 1
        }

        # Extract backup size from output
        BACKUP_SIZE=$(echo "$BACKUP_OUTPUT" | grep "^SIZE:" | cut -d: -f2)

        # Output backup information
        echo "$BACKUP_OUTPUT"
        echo ""
        echo "=========================================="
        echo "✓ Backup completed successfully"
        echo "=========================================="
        echo "Backup location: $BACKUP_PATH"
        echo "Backup size: $BACKUP_SIZE"
        echo "=========================================="
        echo ""

        # Set outputs
        echo "created=true" >> $GITHUB_OUTPUT
        echo "path=$BACKUP_PATH" >> $GITHUB_OUTPUT
        echo "size=$BACKUP_SIZE" >> $GITHUB_OUTPUT

        # Optional: Implement backup retention policy (keep last 10 backups)
        echo "Checking backup retention policy..."
        ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "
          set -e
          cd \"$BACKUP_DIR\"
          
          # Count backup files for this destination
          BACKUP_COUNT=\$(ls -1 backup_${DEST_BASENAME}_*.tar.gz 2>/dev/null | wc -l)
          
          if [ \"\$BACKUP_COUNT\" -gt 10 ]; then
            echo \"Found \$BACKUP_COUNT backups, removing oldest to keep last 10...\"
            # Remove oldest backups, keep last 10
            ls -1t backup_${DEST_BASENAME}_*.tar.gz | tail -n +11 | xargs -r rm -f
            echo \"Old backups cleaned up\"
          else
            echo \"Backup count: \$BACKUP_COUNT (within retention limit)\"
          fi
        " 2>&1 || echo "Note: Backup retention cleanup encountered an issue (non-critical)"

        echo "Backup process completed, proceeding with file transfer..."

    - name: Transfer files
      shell: bash
      id: transfer
      if: success() || (failure() && steps.backup.conclusion == 'skipped')
      run: |
        set -e
        echo "Starting file transfer..."

        # Create temp directory for operations
        TEMP_DIR=$(mktemp -d)

        # Generate random string for unique temporary directories and files
        RANDOM_ID=$(openssl rand -hex 8)
        TIMESTAMP=$(date +%s)
        UNIQUE_SUFFIX="${TIMESTAMP}_${RANDOM_ID}"

        # Remote temporary directory path (using unique random name)
        REMOTE_TEMP_DIR="/tmp/sshft_temp_${UNIQUE_SUFFIX}"

        # Set cleanup trap for unexpected exits
        cleanup() {
          echo "Cleaning up temporary files..."
          # Clean up local temp directory
          rm -rf "$TEMP_DIR" 2>/dev/null || true
          # Clean up remote temp directory and any temp files
          ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "rm -rf \"$REMOTE_TEMP_DIR\" /tmp/sshft_*_${UNIQUE_SUFFIX}.tar.gz" 2>/dev/null || true
        }
        trap cleanup EXIT

        # Get the base name of the source path for the tar.gz file
        SOURCE_PATH="${{ inputs.source }}"
        if [[ "$SOURCE_PATH" == */ ]]; then
          SOURCE_PATH="${SOURCE_PATH%/}"
        fi
        BASE_NAME=$(basename "$SOURCE_PATH")
        TAR_FILE="sshft_${BASE_NAME}_${UNIQUE_SUFFIX}.tar.gz"

        # Function to check if a file is already compressed
        is_compressed() {
          local file="$1"
          local mime_type
          local extension
          
          # Get file extension
          extension="${file##*.}"
          extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')
          
          # Check common compressed file extensions
          case "$extension" in
            gz|tgz|tar.gz|bz2|tbz2|tar.bz2|xz|txz|tar.xz|zip|rar|7z|tar|lz4|zst)
              return 0
              ;;
          esac
          
          # Check MIME type if file command is available
          if command -v file >/dev/null 2>&1; then
            mime_type=$(file -b --mime-type "$file" 2>/dev/null || echo "")
            case "$mime_type" in
              application/gzip|application/x-gzip|application/x-bzip2|application/x-xz|application/zip|application/x-tar|application/x-compressed-tar)
                return 0
                ;;
            esac
          fi
          
          return 1
        }

        if [[ "${{ inputs.direction }}" == "upload" ]]; then
          # UPLOAD: Local -> Remote
          
          # Check if the source exists locally
          if [ ! -e "$SOURCE_PATH" ]; then
            echo "Error: Source file or directory does not exist: $SOURCE_PATH"
            echo "error=Source file or directory not found" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Calculate source size for validation and disk space check
          echo "Calculating source size..."
          if [ -d "$SOURCE_PATH" ]; then
            SOURCE_SIZE_BYTES=$(du -sb "$SOURCE_PATH" 2>/dev/null | cut -f1 || echo 0)
          else
            SOURCE_SIZE_BYTES=$(stat -c%s "$SOURCE_PATH" 2>/dev/null || stat -f%z "$SOURCE_PATH" 2>/dev/null || echo 0)
          fi

          SOURCE_SIZE_MB=$((SOURCE_SIZE_BYTES / 1024 / 1024))
          echo "Source size: ${SOURCE_SIZE_MB}MB (${SOURCE_SIZE_BYTES} bytes)"

          # Security: Prevent resource exhaustion with reasonable file size limit (2GB by default)
          MAX_SIZE_BYTES=$((2 * 1024 * 1024 * 1024))
          if [ "$SOURCE_SIZE_BYTES" -gt "$MAX_SIZE_BYTES" ]; then
            echo "Error: Source size (${SOURCE_SIZE_MB}MB) exceeds maximum allowed size (2GB)"
            echo "error=Source size exceeds limit" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check if we need compression
          local file="$1"
          local mime_type
          local extension
          
          # Get file extension
          extension="${file##*.}"
          extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')
          
          # Check common compressed file extensions
          case "$extension" in
            gz|tgz|tar.gz|bz2|tbz2|tar.bz2|xz|txz|tar.xz|zip|rar|7z|tar|lz4|zst)
              return 0 ;;
          esac
          
          # Check MIME type if file command is available
          if command -v file >/dev/null 2>&1; then
            mime_type=$(file -b --mime-type "$file" 2>/dev/null || echo "")
            case "$mime_type" in
              application/gzip|application/x-gzip|application/x-tar|application/zip|application/x-rar|application/x-7z-compressed|application/x-bzip2|application/x-xz)
                return 0 ;;
            esac
          fi
          
          
          # Check if we need compression
          NEEDS_COMPRESSION=true
          TRANSFER_FILE=""
          
          if [ -f "$SOURCE_PATH" ] && is_compressed "$SOURCE_PATH"; then
            echo "Source file is already compressed, transferring directly..."
            NEEDS_COMPRESSION=false
            TRANSFER_FILE="$SOURCE_PATH"
          elif [ -d "$SOURCE_PATH" ]; then
            # Check if directory contains only compressed files
            COMPRESSED_COUNT=$(find "$SOURCE_PATH" -type f -exec sh -c 'case "${1##*.}" in gz|tgz|tar.gz|bz2|tbz2|tar.bz2|xz|txz|tar.xz|zip|rar|7z|tar|lz4|zst) exit 0;; *) exit 1;; esac' _ {} \; 2>/dev/null | wc -l || echo 0)
            TOTAL_FILES=$(find "$SOURCE_PATH" -type f | wc -l)
            
            if [ "$COMPRESSED_COUNT" -eq "$TOTAL_FILES" ] && [ "$TOTAL_FILES" -gt 0 ]; then
              echo "Directory contains only compressed files, compressing anyway for consistency..."
            fi
            
            echo "Compressing directory..."
            tar -czf "$TEMP_DIR/$TAR_FILE" -C "$(dirname "$SOURCE_PATH")" "$(basename "$SOURCE_PATH")"
            TRANSFER_FILE="$TEMP_DIR/$TAR_FILE"
          else
            echo "Compressing source file..."
            tar -czf "$TEMP_DIR/$TAR_FILE" -C "$(dirname "$SOURCE_PATH")" "$(basename "$SOURCE_PATH")"
            TRANSFER_FILE="$TEMP_DIR/$TAR_FILE"
          fi
          
          # Create remote temp directory
          echo "Creating remote temporary directory..."
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "mkdir -p \"$REMOTE_TEMP_DIR\""; then
            echo "Error: Failed to create remote temporary directory"
            echo "error=Remote temp dir creation failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Transfer the file to remote server
          echo "Transferring file to remote server..."
          if [ "$NEEDS_COMPRESSION" = true ]; then
            REMOTE_FILE="$REMOTE_TEMP_DIR/$TAR_FILE"
          else
            REMOTE_FILE="$REMOTE_TEMP_DIR/$(basename "$SOURCE_PATH")"
          fi
          
          if ! scp -F "$SSH_CONFIG_FILE" "$TRANSFER_FILE" "${{ inputs.host }}:$REMOTE_FILE"; then
            echo "Error: Failed to transfer file to remote server"
            echo "error=File transfer failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Normalize and validate destination path
          DEST_PATH="${{ inputs.destination }}"
          if [[ "$DEST_PATH" == */ ]]; then
            DEST_PATH="${DEST_PATH%/}"
          fi
          
          # Verify destination directory exists and is writable
          DEST_CHECK=$(ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "
            set -e
            
            # Check if destination exists
            if [ ! -e \"$DEST_PATH\" ]; then
              echo 'ERROR:Destination does not exist'
              exit 1
            fi
            
            # Check if it's a directory
            if [ ! -d \"$DEST_PATH\" ]; then
              echo 'ERROR:Destination is not a directory'
              exit 1
            fi
            
            # Check if writable
            if [ ! -w \"$DEST_PATH\" ]; then
              echo 'ERROR:Destination is not writable'
              exit 1
            fi
            
            # Security: Check if destination is a symlink pointing outside allowed paths
            if [ -L \"$DEST_PATH\" ]; then
              REAL_PATH=\$(realpath \"$DEST_PATH\" 2>/dev/null || readlink -f \"$DEST_PATH\" 2>/dev/null || echo '')
              if [ -z \"\$REAL_PATH\" ]; then
                echo 'ERROR:Cannot resolve symlink destination'
                exit 1
              fi
              echo 'WARNING:Destination is a symlink'
            fi
            
            echo 'OK:Destination validated'
          " 2>&1) || DEST_ERROR=$?
          
          if [ -n "$DEST_ERROR" ] && [ "$DEST_ERROR" -ne 0 ]; then
            ERROR_MSG=$(echo "$DEST_CHECK" | grep "^ERROR:" | sed 's/^ERROR://' | head -n 1)
            echo "Error: ${ERROR_MSG:-Destination directory issue}"
            echo "error=Destination validation failed: ${ERROR_MSG:-unknown}" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Show warnings if any
          echo "$DEST_CHECK" | grep "^WARNING:" | sed 's/^WARNING:/Warning: /' || true
          
          # Check remote disk space before transfer
          echo "Checking remote disk space..."
          REMOTE_SPACE_CHECK=$(ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "
            set -e
            # Get available space in bytes
            AVAILABLE_BYTES=\$(df -B1 \"$DEST_PATH\" | tail -1 | awk '{print \$4}')
            # Add 20% buffer for compression overhead
            REQUIRED_BYTES=$((SOURCE_SIZE_BYTES + SOURCE_SIZE_BYTES / 5))
            
            if [ \"\$AVAILABLE_BYTES\" -lt \"\$REQUIRED_BYTES\" ]; then
              AVAILABLE_MB=\$((\$AVAILABLE_BYTES / 1024 / 1024))
              REQUIRED_MB=\$((\$REQUIRED_BYTES / 1024 / 1024))
              echo \"ERROR:Insufficient disk space (available: \${AVAILABLE_MB}MB, required: \${REQUIRED_MB}MB)\"
              exit 1
            fi
            
            echo \"OK:Sufficient disk space\"
          " 2>&1) || SPACE_ERROR=$?
          
          if [ -n "$SPACE_ERROR" ] && [ "$SPACE_ERROR" -ne 0 ]; then
            ERROR_MSG=$(echo "$REMOTE_SPACE_CHECK" | grep "^ERROR:" | sed 's/^ERROR://' | head -n 1)
            echo "Error: ${ERROR_MSG:-Insufficient remote disk space}"
            echo "error=Disk space check failed: ${ERROR_MSG:-unknown}" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Extract/move files on remote server
          BASENAME_SOURCE=$(basename "$SOURCE_PATH")
          if [ "$NEEDS_COMPRESSION" = true ]; then
            echo "Extracting files on remote server..."
            if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "cd \"$REMOTE_TEMP_DIR\" && tar -xzf \"$TAR_FILE\" && cp -r \"$BASENAME_SOURCE\"/* \"$DEST_PATH/\""; then
              echo "Error: Failed to extract files on remote server"
              echo "error=Remote extraction failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "Moving compressed file to destination..."
            if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "cp \"$REMOTE_FILE\" \"$DEST_PATH/\""; then
              echo "Error: Failed to move file to destination"
              echo "error=Remote file move failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
        else
          # DOWNLOAD: Remote -> Local
          # Normalize remote source path (remove trailing slash)
          REMOTE_SOURCE="${{ inputs.source }}"
          if [[ "$REMOTE_SOURCE" == */ ]]; then
            REMOTE_SOURCE="${REMOTE_SOURCE%/}"
          fi
          
          # Verify remote source exists
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "[ -e \"$REMOTE_SOURCE\" ]"; then
            echo "Error: Remote source does not exist: $REMOTE_SOURCE"
            echo "error=Remote source not found" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Calculate remote source size for validation
          echo "Calculating remote source size..."
          REMOTE_SIZE_BYTES=$(ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "
            if [ -d \"$REMOTE_SOURCE\" ]; then
              du -sb \"$REMOTE_SOURCE\" 2>/dev/null | cut -f1 || echo 0
            else
              stat -c%s \"$REMOTE_SOURCE\" 2>/dev/null || stat -f%z \"$REMOTE_SOURCE\" 2>/dev/null || echo 0
            fi
          " 2>&1) || REMOTE_SIZE_BYTES=0
          
          REMOTE_SIZE_MB=$((REMOTE_SIZE_BYTES / 1024 / 1024))
          echo "Remote source size: ${REMOTE_SIZE_MB}MB (${REMOTE_SIZE_BYTES} bytes)"
          
          # Security: Prevent resource exhaustion with reasonable file size limit (10GB)
          MAX_SIZE_BYTES=$((10 * 1024 * 1024 * 1024))
          if [ "$REMOTE_SIZE_BYTES" -gt "$MAX_SIZE_BYTES" ]; then
            echo "Error: Remote source size (${REMOTE_SIZE_MB}MB) exceeds maximum allowed size (10GB)"
            echo "error=Remote source size exceeds limit" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Create remote temp directory
          echo "Creating remote temporary directory..."
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "mkdir -p \"$REMOTE_TEMP_DIR\""; then
            echo "Error: Failed to create remote temporary directory"
            echo "error=Remote temp dir creation failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          REMOTE_DIR=$(dirname "$REMOTE_SOURCE")
          REMOTE_BASE=$(basename "$REMOTE_SOURCE")
          NEEDS_COMPRESSION=true
          DOWNLOAD_FILE=""
          
          # Check if source is a single compressed file
          if ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "[ -f \"$REMOTE_SOURCE\" ]"; then
            # Check if it's compressed by extension
            case "${REMOTE_BASE##*.}" in
              gz|tgz|tar.gz|bz2|tbz2|tar.bz2|xz|txz|tar.xz|zip|rar|7z|tar|lz4|zst)
                echo "Remote source is already compressed, downloading directly..."
                NEEDS_COMPRESSION=false
                DOWNLOAD_FILE="$REMOTE_TEMP_DIR/$REMOTE_BASE"
                # Copy file to temp directory
                if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "cp \"$REMOTE_SOURCE\" \"$DOWNLOAD_FILE\""; then
                  echo "Error: Failed to copy remote file to temp directory"
                  echo "error=Remote file copy failed" >> $GITHUB_OUTPUT
                  exit 1
                fi
                ;;
              *)
                echo "Compressing single file on remote server..."
                DOWNLOAD_FILE="$REMOTE_TEMP_DIR/$TAR_FILE"
                if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "tar -czf \"$DOWNLOAD_FILE\" -C \"$REMOTE_DIR\" \"$REMOTE_BASE\""; then
                  echo "Error: Failed to compress file on remote server"
                  echo "error=Remote compression failed" >> $GITHUB_OUTPUT
                  exit 1
                fi
                ;;
            esac
          else
            # Directory - always compress for consistency
            echo "Compressing directory on remote server..."
            DOWNLOAD_FILE="$REMOTE_TEMP_DIR/$TAR_FILE"
            if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "tar -czf \"$DOWNLOAD_FILE\" -C \"$REMOTE_DIR\" \"$REMOTE_BASE\""; then
              echo "Error: Failed to compress directory on remote server"
              echo "error=Remote compression failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
          # Download the file
          echo "Downloading file from remote server..."
          LOCAL_DOWNLOAD_FILE="$TEMP_DIR/$(basename "$DOWNLOAD_FILE")"
          if ! scp -F "$SSH_CONFIG_FILE" "${{ inputs.host }}:$DOWNLOAD_FILE" "$LOCAL_DOWNLOAD_FILE"; then
            echo "Error: Failed to download file"
            echo "error=Download failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Validate and create local destination directory
          LOCAL_DEST="${{ inputs.destination }}"
          if [[ "$LOCAL_DEST" == */ ]]; then
            LOCAL_DEST="${LOCAL_DEST%/}"
          fi
          
          # Check if destination exists and validate it
          if [ -e "$LOCAL_DEST" ]; then
            # Exists - verify it's a directory and writable
            if [ ! -d "$LOCAL_DEST" ]; then
              echo "Error: Local destination exists but is not a directory: $LOCAL_DEST"
              echo "error=Local destination is not a directory" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            if [ ! -w "$LOCAL_DEST" ]; then
              echo "Error: Local destination directory is not writable: $LOCAL_DEST"
              echo "error=Local destination is not writable" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            # Security: Check if destination is a symlink
            if [ -L "$LOCAL_DEST" ]; then
              REAL_DEST=$(realpath "$LOCAL_DEST" 2>/dev/null || readlink -f "$LOCAL_DEST" 2>/dev/null || echo '')
              if [ -z "$REAL_DEST" ]; then
                echo "Error: Cannot resolve symlink destination: $LOCAL_DEST"
                echo "error=Cannot resolve local destination symlink" >> $GITHUB_OUTPUT
                exit 1
              fi
              echo "Warning: Local destination is a symlink pointing to: $REAL_DEST"
            fi
          else
            # Doesn't exist - create it with proper permissions
            echo "Creating local destination directory: $LOCAL_DEST"
            if ! mkdir -p "$LOCAL_DEST" 2>&1; then
              echo "Error: Failed to create local destination directory: $LOCAL_DEST"
              echo "error=Failed to create local destination directory" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            # Verify it was created and is writable
            if [ ! -d "$LOCAL_DEST" ] || [ ! -w "$LOCAL_DEST" ]; then
              echo "Error: Failed to create writable destination directory"
              echo "error=Destination directory creation failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
          # Check local disk space before download
          echo "Checking local disk space..."
          AVAILABLE_BYTES=$(df -B1 "$LOCAL_DEST" | tail -1 | awk '{print $4}')
          # Add 20% buffer for extraction overhead
          REQUIRED_BYTES=$((REMOTE_SIZE_BYTES + REMOTE_SIZE_BYTES / 5))
          
          if [ "$AVAILABLE_BYTES" -lt "$REQUIRED_BYTES" ]; then
            AVAILABLE_MB=$((AVAILABLE_BYTES / 1024 / 1024))
            REQUIRED_MB=$((REQUIRED_BYTES / 1024 / 1024))
            echo "Error: Insufficient local disk space (available: ${AVAILABLE_MB}MB, required: ${REQUIRED_MB}MB)"
            echo "error=Insufficient local disk space" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Extract/move files locally
          if [ "$NEEDS_COMPRESSION" = true ]; then
            echo "Extracting files locally..."
            if ! tar -xzf "$LOCAL_DOWNLOAD_FILE" -C "$TEMP_DIR"; then
              echo "Error: Failed to extract files locally"
              echo "error=Local extraction failed" >> $GITHUB_OUTPUT
              exit 1
            fi
            # Copy extracted content to destination
            if ! cp -r "$TEMP_DIR/$REMOTE_BASE"/* "$LOCAL_DEST/"; then
              echo "Error: Failed to copy extracted files to destination"
              echo "error=Local copy failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "Moving downloaded compressed file to destination..."
            if ! cp "$LOCAL_DOWNLOAD_FILE" "$LOCAL_DEST/"; then
              echo "Error: Failed to move downloaded file to destination"
              echo "error=Local file move failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
        fi

        echo "File transfer completed successfully"
        echo "success=true" >> $GITHUB_OUTPUT

        # Manual cleanup (trap will also run)
        echo "Cleaning up temporary files..."
        rm -rf "$TEMP_DIR" 2>/dev/null || true
        ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "rm -rf \"$REMOTE_TEMP_DIR\"" 2>/dev/null || true

    - name: Execute post-transfer script
      shell: bash
      id: post_script
      if: success() && (inputs.post_script != '' || inputs.post_script_path != '')
      run: |
        set +e  # Don't fail immediately on errors for this step
        echo "executed=false" >> $GITHUB_OUTPUT
        echo "error=" >> $GITHUB_OUTPUT
        echo "output=" >> $GITHUB_OUTPUT

        # Generate random ID for temporary script file
        RANDOM_ID=$(openssl rand -hex 8)
        TIMESTAMP=$(date +%s)
        TEMP_SCRIPT="/tmp/sshft_script_${TIMESTAMP}_${RANDOM_ID}.sh"

        # Cleanup function for script execution
        cleanup_script() {
          ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "rm -f \"$TEMP_SCRIPT\"" 2>/dev/null || true
        }
        trap cleanup_script EXIT

        # Determine which script to execute
        if [ -n "${{ inputs.post_script }}" ]; then
          echo "Executing inline post-transfer script..."
          
          # Validate that the script is not empty after trimming
          TRIMMED_SCRIPT=$(echo "${{ inputs.post_script }}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          if [ -z "$TRIMMED_SCRIPT" ]; then
            echo "Error: Inline script is empty or contains only whitespace"
            echo "error=Script is empty or malformed" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Create temporary script file locally first for validation
          LOCAL_TEMP_SCRIPT=$(mktemp)
          echo '#!/bin/bash' > "$LOCAL_TEMP_SCRIPT"
          echo 'set -e' >> "$LOCAL_TEMP_SCRIPT"
          echo "${{ inputs.post_script }}" >> "$LOCAL_TEMP_SCRIPT"
          chmod +x "$LOCAL_TEMP_SCRIPT"
          
          # Perform comprehensive local syntax validation
          echo "Validating script syntax..."
          SYNTAX_CHECK=$(bash -n "$LOCAL_TEMP_SCRIPT" 2>&1) || SYNTAX_ERROR=$?
          
          if [ -n "$SYNTAX_ERROR" ] && [ "$SYNTAX_ERROR" -ne 0 ]; then
            echo "Error: Script has syntax errors:"
            echo "$SYNTAX_CHECK"
            echo "error=Script syntax error: unexpected token or malformed command" >> $GITHUB_OUTPUT
            rm -f "$LOCAL_TEMP_SCRIPT"
            exit 0
          fi
          
          # Additional validation: check for potentially dangerous or malformed patterns
          echo "Performing additional script validation..."
          
          # Security: Check for dangerous commands that could damage the system
          echo "Checking for dangerous commands..."
          DANGEROUS_PATTERNS=(
            'rm[[:space:]]+-rf[[:space:]]*/'
            'rm[[:space:]]+-rf[[:space:]]*~'
            'dd[[:space:]]+if=/dev/(zero|random|urandom)[[:space:]]+of=/dev/'
            ':(){.*:.*&.*};:'
            'mkfs\.'
            'fdisk'
            'parted'
            'mkswap'
            'swapon'
            'swapoff'
            'reboot'
            'shutdown'
            'halt'
            'poweroff'
            'init[[:space:]]+[0-6]'
            'systemctl[[:space:]]+(poweroff|reboot|halt)'
            'kill[[:space:]]+-9[[:space:]]+1'
            'kill[[:space:]]+-9[[:space:]]+\$\$'
            'pkill[[:space:]]+-9'
            'killall[[:space:]]+-9'
            '>[[:space:]]*/dev/sd'
            '>[[:space:]]*/dev/nvme'
            'wipefs'
            'shred[[:space:]]+-.*[[:space:]]*/dev/'
            'chown[[:space:]]+-R[[:space:]]+.*[[:space:]]*:.*[[:space:]]*/'
            'chmod[[:space:]]+-R[[:space:]]+777[[:space:]]*/'
            'curl.*\|[[:space:]]*bash'
            'wget.*\|[[:space:]]*bash'
            'curl.*\|[[:space:]]*sh'
            'wget.*\|[[:space:]]*sh'
            'eval[[:space:]]+\$\('
            '/etc/shadow'
            '/etc/passwd'
            'iptables[[:space:]]+-F'
            'ufw[[:space:]]+disable'
            'setenforce[[:space:]]+0'
          )
          
          DANGEROUS_FOUND=""
          for pattern in "${DANGEROUS_PATTERNS[@]}"; do
            if grep -qE "$pattern" "$LOCAL_TEMP_SCRIPT" 2>/dev/null; then
              COMMAND_SAMPLE=$(grep -E "$pattern" "$LOCAL_TEMP_SCRIPT" | head -n 1 | sed 's/^[[:space:]]*//')
              DANGEROUS_FOUND="${DANGEROUS_FOUND}Potentially dangerous command detected: ${COMMAND_SAMPLE:0:60}...\n"
            fi
          done
          
          if [ -n "$DANGEROUS_FOUND" ]; then
            echo "Error: Script contains potentially dangerous commands:"
            echo -e "$DANGEROUS_FOUND"
            echo "error=Script blocked: contains dangerous commands" >> $GITHUB_OUTPUT
            rm -f "$LOCAL_TEMP_SCRIPT"
            exit 0
          fi
          
          # Check for command injection attempts
          if grep -qE '\$\(.*\$\{' "$LOCAL_TEMP_SCRIPT" 2>/dev/null; then
            echo "Error: Script contains nested command substitution which may indicate injection attempt"
            echo "error=Script blocked: suspicious command substitution" >> $GITHUB_OUTPUT
            rm -f "$LOCAL_TEMP_SCRIPT"
            exit 0
          fi
          
          # Check for privilege escalation attempts
          if grep -qE '^[[:space:]]*(sudo|su[[:space:]])' "$LOCAL_TEMP_SCRIPT" 2>/dev/null; then
            echo "Error: Script contains privilege escalation commands (sudo/su)"
            echo "error=Script blocked: privilege escalation attempt" >> $GITHUB_OUTPUT
            rm -f "$LOCAL_TEMP_SCRIPT"
            exit 0
          fi
          
          # Check for unmatched quotes
          if grep -qE "^[^#]*(['\"])([^\\1]*)$" "$LOCAL_TEMP_SCRIPT" 2>/dev/null; then
            echo "Warning: Script may contain unmatched quotes"
          fi
          
          # Check for common syntax issues that bash -n might miss
          VALIDATION_ERRORS=""
          
          # Check for pipes without commands
          if grep -qE '\|[[:space:]]*(\||;|$)' "$LOCAL_TEMP_SCRIPT" 2>/dev/null; then
            VALIDATION_ERRORS="${VALIDATION_ERRORS}Pipeline without command detected\n"
          fi
          
          # Check for unmatched braces/brackets
          OPEN_BRACES=$(grep -o '{' "$LOCAL_TEMP_SCRIPT" 2>/dev/null | wc -l)
          CLOSE_BRACES=$(grep -o '}' "$LOCAL_TEMP_SCRIPT" 2>/dev/null | wc -l)
          if [ "$OPEN_BRACES" -ne "$CLOSE_BRACES" ]; then
            VALIDATION_ERRORS="${VALIDATION_ERRORS}Unmatched braces detected (open: $OPEN_BRACES, close: $CLOSE_BRACES)\n"
          fi
          
          # Check for unmatched parentheses in arithmetic or subshells
          OPEN_PARENS=$(grep -o '(' "$LOCAL_TEMP_SCRIPT" 2>/dev/null | wc -l)
          CLOSE_PARENS=$(grep -o ')' "$LOCAL_TEMP_SCRIPT" 2>/dev/null | wc -l)
          if [ "$OPEN_PARENS" -ne "$CLOSE_PARENS" ]; then
            VALIDATION_ERRORS="${VALIDATION_ERRORS}Unmatched parentheses detected (open: $OPEN_PARENS, close: $CLOSE_PARENS)\n"
          fi
          
          # Check for unmatched square brackets
          OPEN_BRACKETS=$(grep -o '\[' "$LOCAL_TEMP_SCRIPT" 2>/dev/null | wc -l)
          CLOSE_BRACKETS=$(grep -o '\]' "$LOCAL_TEMP_SCRIPT" 2>/dev/null | wc -l)
          if [ "$OPEN_BRACKETS" -ne "$CLOSE_BRACKETS" ]; then
            VALIDATION_ERRORS="${VALIDATION_ERRORS}Unmatched brackets detected (open: $OPEN_BRACKETS, close: $CLOSE_BRACKETS)\n"
          fi
          
          if [ -n "$VALIDATION_ERRORS" ]; then
            echo "Error: Script validation failed:"
            echo -e "$VALIDATION_ERRORS"
            echo "error=Script validation failed: malformed syntax" >> $GITHUB_OUTPUT
            rm -f "$LOCAL_TEMP_SCRIPT"
            exit 0
          fi
          
          echo "✓ Script syntax validation passed"
          
          # Upload script to remote server
          if ! scp -F "$SSH_CONFIG_FILE" "$LOCAL_TEMP_SCRIPT" "${{ inputs.host }}:$TEMP_SCRIPT" 2>&1; then
            echo "Error: Failed to upload script to remote server"
            echo "error=Failed to upload script file" >> $GITHUB_OUTPUT
            rm -f "$LOCAL_TEMP_SCRIPT"
            exit 0
          fi
          
          # Make script executable on remote
          if ! ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "chmod +x \"$TEMP_SCRIPT\"" 2>&1; then
            echo "Error: Failed to make script executable on remote server"
            echo "error=Failed to set script permissions" >> $GITHUB_OUTPUT
            rm -f "$LOCAL_TEMP_SCRIPT"
            exit 0
          fi
          
          # Validate script syntax on remote server as well (double-check)
          echo "Validating script syntax on remote server..."
          REMOTE_SYNTAX_CHECK=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "bash -n \"$TEMP_SCRIPT\"" 2>&1) || REMOTE_SYNTAX_ERROR=$?
          
          if [ -n "$REMOTE_SYNTAX_ERROR" ] && [ "$REMOTE_SYNTAX_ERROR" -ne 0 ]; then
            echo "Error: Script has syntax errors on remote server:"
            echo "$REMOTE_SYNTAX_CHECK"
            echo "error=Remote script syntax validation failed" >> $GITHUB_OUTPUT
            rm -f "$LOCAL_TEMP_SCRIPT"
            exit 0
          fi
          
          rm -f "$LOCAL_TEMP_SCRIPT"
          
          echo "✓ Remote script syntax validation passed"
          echo "Executing script on remote server in restricted mode..."
          
          # Execute the script in a restricted environment with timeout
          # Set resource limits to prevent fork bombs and excessive resource usage
          SCRIPT_OUTPUT=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "
            # Set resource limits
            ulimit -u 100      # Max 100 user processes
            ulimit -f 1048576  # Max file size 1GB
            ulimit -t 300      # Max CPU time 5 minutes
            ulimit -v 2097152  # Max virtual memory 2GB
            
            # Execute with timeout (10 minutes max)
            timeout 600 bash \"$TEMP_SCRIPT\"
          " 2>&1) || SCRIPT_EXIT_CODE=$?
          
          if [ -n "$SCRIPT_EXIT_CODE" ] && [ "$SCRIPT_EXIT_CODE" -ne 0 ]; then
            echo "Error: Script execution failed with exit code $SCRIPT_EXIT_CODE"
            echo "error=Script execution failed with exit code $SCRIPT_EXIT_CODE" >> $GITHUB_OUTPUT
            echo "$SCRIPT_OUTPUT"
            exit 0
          fi
          
          echo "executed=true" >> $GITHUB_OUTPUT
          # Sanitize output for GitHub Actions (remove special characters that might break output)
          SANITIZED_OUTPUT=$(echo "$SCRIPT_OUTPUT" | tr -d '\000-\010\013\014\016-\037' | head -c 10000)
          echo "output<<SSHFT_OUTPUT_EOF" >> $GITHUB_OUTPUT
          echo "$SANITIZED_OUTPUT" >> $GITHUB_OUTPUT
          echo "SSHFT_OUTPUT_EOF" >> $GITHUB_OUTPUT
          echo "✓ Inline script executed successfully"
          
        elif [ -n "${{ inputs.post_script_path }}" ]; then
          echo "Executing script from remote server path: ${{ inputs.post_script_path }}"
          
          # Check if the script file exists on remote server
          if ! ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "test -f \"${{ inputs.post_script_path }}\"" 2>&1; then
            echo "Error: Script file does not exist at path: ${{ inputs.post_script_path }}"
            echo "error=Script file does not exist" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if the script file is readable
          if ! ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "test -r \"${{ inputs.post_script_path }}\"" 2>&1; then
            echo "Error: Script file is not readable: ${{ inputs.post_script_path }}"
            echo "error=Script file is not readable" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if file is empty
          FILE_SIZE=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "stat -c%s \"${{ inputs.post_script_path }}\" 2>/dev/null || stat -f%z \"${{ inputs.post_script_path }}\" 2>/dev/null || echo 0")
          if [ "$FILE_SIZE" -eq 0 ]; then
            echo "Error: Script file is empty"
            echo "error=Script file is empty" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Comprehensive syntax validation
          echo "Validating script syntax..."
          SYNTAX_CHECK=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "bash -n \"${{ inputs.post_script_path }}\"" 2>&1) || SYNTAX_ERROR=$?
          
          if [ -n "$SYNTAX_ERROR" ] && [ "$SYNTAX_ERROR" -ne 0 ]; then
            echo "Error: Script has syntax errors:"
            echo "$SYNTAX_CHECK"
            echo "error=Script syntax error: unexpected token or malformed command" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Additional validation: check script content for common issues
          echo "Performing additional script validation..."
          
          # Security: Check for dangerous commands on remote server
          echo "Checking for dangerous commands..."
          DANGEROUS_CHECK=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "
            set -e
            SCRIPT_PATH=\"${{ inputs.post_script_path }}\"
            
            # Check for extremely dangerous patterns
            if grep -qE 'rm[[:space:]]+-rf[[:space:]]*/|rm[[:space:]]+-rf[[:space:]]*~|rm[[:space:]]+-rf[[:space:]]*/' \"\$SCRIPT_PATH\" 2>/dev/null; then
              echo 'ERROR:Dangerous rm command detected'
              exit 1
            fi
            
            if grep -qE 'dd[[:space:]]+if=/dev/(zero|random|urandom)[[:space:]]+of=/dev/' \"\$SCRIPT_PATH\" 2>/dev/null; then
              echo 'ERROR:Dangerous dd command detected'
              exit 1
            fi
            
            if grep -qE ':[(][)]\{.*:.*&.*\};:' \"\$SCRIPT_PATH\" 2>/dev/null; then
              echo 'ERROR:Fork bomb detected'
              exit 1
            fi
            
            if grep -qE 'mkfs\\.|fdisk|parted|wipefs' \"\$SCRIPT_PATH\" 2>/dev/null; then
              echo 'ERROR:Disk formatting command detected'
              exit 1
            fi
            
            if grep -qE 'shutdown|reboot|halt|poweroff' \"\$SCRIPT_PATH\" 2>/dev/null; then
              echo 'ERROR:System shutdown command detected'
              exit 1
            fi
            
            if grep -qE '^[[:space:]]*(sudo|su[[:space:]])' \"\$SCRIPT_PATH\" 2>/dev/null; then
              echo 'ERROR:Privilege escalation detected'
              exit 1
            fi
            
            if grep -qE 'curl.*\\|[[:space:]]*bash|wget.*\\|[[:space:]]*bash|curl.*\\|[[:space:]]*sh|wget.*\\|[[:space:]]*sh' \"\$SCRIPT_PATH\" 2>/dev/null; then
              echo 'ERROR:Remote code execution pattern detected'
              exit 1
            fi
            
            echo 'OK:Security validation passed'
          " 2>&1) || DANGEROUS_ERROR=$?
          
          if [ -n "$DANGEROUS_ERROR" ] && [ "$DANGEROUS_ERROR" -ne 0 ]; then
            ERROR_MSG=$(echo "$DANGEROUS_CHECK" | grep "^ERROR:" | sed 's/^ERROR://' | head -n 1)
            echo "Error: ${ERROR_MSG:-Script contains dangerous commands}"
            echo "error=Script blocked: ${ERROR_MSG:-dangerous commands detected}" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          VALIDATION_OUTPUT=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "
            set -e
            SCRIPT_PATH=\"${{ inputs.post_script_path }}\"
            
            # Check for unmatched braces
            OPEN_BRACES=\$(grep -o '{' \"\$SCRIPT_PATH\" 2>/dev/null | wc -l)
            CLOSE_BRACES=\$(grep -o '}' \"\$SCRIPT_PATH\" 2>/dev/null | wc -l)
            if [ \"\$OPEN_BRACES\" -ne \"\$CLOSE_BRACES\" ]; then
              echo \"ERROR:Unmatched braces (open: \$OPEN_BRACES, close: \$CLOSE_BRACES)\"
              exit 1
            fi
            
            # Check for unmatched parentheses
            OPEN_PARENS=\$(grep -o '(' \"\$SCRIPT_PATH\" 2>/dev/null | wc -l)
            CLOSE_PARENS=\$(grep -o ')' \"\$SCRIPT_PATH\" 2>/dev/null | wc -l)
            if [ \"\$OPEN_PARENS\" -ne \"\$CLOSE_PARENS\" ]; then
              echo \"ERROR:Unmatched parentheses (open: \$OPEN_PARENS, close: \$CLOSE_PARENS)\"
              exit 1
            fi
            
            # Check for unmatched brackets
            OPEN_BRACKETS=\$(grep -o '\[' \"\$SCRIPT_PATH\" 2>/dev/null | wc -l)
            CLOSE_BRACKETS=\$(grep -o '\]' \"\$SCRIPT_PATH\" 2>/dev/null | wc -l)
            if [ \"\$OPEN_BRACKETS\" -ne \"\$CLOSE_BRACKETS\" ]; then
              echo \"ERROR:Unmatched brackets (open: \$OPEN_BRACKETS, close: \$CLOSE_BRACKETS)\"
              exit 1
            fi
            
            # Check for pipes without commands
            if grep -qE '\|[[:space:]]*(\||;|\$)' \"\$SCRIPT_PATH\" 2>/dev/null; then
              echo \"WARNING:Pipeline without command detected\"
            fi
            
            echo \"OK:Validation passed\"
          " 2>&1) || VALIDATION_ERROR=$?
          
          if [ -n "$VALIDATION_ERROR" ] && [ "$VALIDATION_ERROR" -ne 0 ]; then
            echo "Error: Script validation failed:"
            echo "$VALIDATION_OUTPUT" | grep "^ERROR:" | sed 's/^ERROR://'
            echo "error=Script validation failed: malformed syntax" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Show warnings if any
          echo "$VALIDATION_OUTPUT" | grep "^WARNING:" | sed 's/^WARNING:/Warning: /' || true
          
          echo "✓ Script syntax validation passed"
          
          # Check if the script is executable, if not try to execute with bash
          if ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "test -x \"${{ inputs.post_script_path }}\"" 2>&1; then
            # Script is executable, run it directly with restrictions
            echo "Executing script on remote server in restricted mode..."
            SCRIPT_OUTPUT=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "
              # Set resource limits
              ulimit -u 100      # Max 100 user processes
              ulimit -f 1048576  # Max file size 1GB
              ulimit -t 300      # Max CPU time 5 minutes
              ulimit -v 2097152  # Max virtual memory 2GB
              
              # Execute with timeout (10 minutes max)
              timeout 600 \"${{ inputs.post_script_path }}\"
            " 2>&1) || SCRIPT_EXIT_CODE=$?
          else
            # Script is not executable, run with bash interpreter
            echo "Note: Script is not executable, running with bash interpreter in restricted mode"
            SCRIPT_OUTPUT=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "
              # Set resource limits
              ulimit -u 100      # Max 100 user processes
              ulimit -f 1048576  # Max file size 1GB
              ulimit -t 300      # Max CPU time 5 minutes
              ulimit -v 2097152  # Max virtual memory 2GB
              
              # Execute with timeout (10 minutes max)
              timeout 600 bash \"${{ inputs.post_script_path }}\"
            " 2>&1) || SCRIPT_EXIT_CODE=$?
          fi
          
          if [ -n "$SCRIPT_EXIT_CODE" ] && [ "$SCRIPT_EXIT_CODE" -ne 0 ]; then
            echo "Error: Script execution failed with exit code $SCRIPT_EXIT_CODE"
            echo "error=Script execution failed with exit code $SCRIPT_EXIT_CODE" >> $GITHUB_OUTPUT
            echo "$SCRIPT_OUTPUT"
            exit 0
          fi
          
          echo "executed=true" >> $GITHUB_OUTPUT
          # Sanitize output for GitHub Actions (remove special characters that might break output)
          SANITIZED_OUTPUT=$(echo "$SCRIPT_OUTPUT" | tr -d '\000-\010\013\014\016-\037' | head -c 10000)
          echo "output<<SSHFT_OUTPUT_EOF" >> $GITHUB_OUTPUT
          echo "$SANITIZED_OUTPUT" >> $GITHUB_OUTPUT
          echo "SSHFT_OUTPUT_EOF" >> $GITHUB_OUTPUT
          echo "✓ Script executed successfully from path: ${{ inputs.post_script_path }}"
        fi

        # Cleanup
        cleanup_script
        trap - EXIT

    - name: Cleanup SSH files securely
      shell: bash
      if: always()
      run: |
        # Terminate any ssh-agent process
        if [ -n "$SSH_AGENT_PID" ]; then
          ssh-agent -k || true
        fi

        # Securely remove SSH files
        if [ -f "$SSH_KEY_FILE" ]; then
          # Overwrite with zeros before deleting
          dd if=/dev/zero of="$SSH_KEY_FILE" bs=1k count=1 conv=notrunc >/dev/null 2>&1 || true
          rm -f "$SSH_KEY_FILE"
        fi

        # Remove other temporary SSH files
        rm -f "$SSH_CONFIG_FILE"
        rm -f "$SSH_KNOWN_HOSTS"

branding:
  icon: "upload-cloud"
  color: "blue"
