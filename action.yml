name: "Secure File Transfer"
description: "A GitHub Action to securely transfer files over SSH using SCP with support for upload and download directions."
author: "KellyDC"
inputs:
  host:
    description: "SSH host to connect to"
    required: true
  port:
    description: "SSH port"
    required: false
    default: "22"
  username:
    description: "SSH username"
    required: true
  key:
    description: "SSH private key"
    required: true
  passphrase:
    description: "Passphrase for the SSH private key"
    required: false
  source:
    description: "Source file or directory to transfer"
    required: true
  destination:
    description: "Destination path on the remote server"
    required: true
  direction:
    description: "Transfer direction"
    required: false
    default: "upload"
  recursive:
    description: "Transfer files recursively"
    required: false
    default: "true"
  strict_host_key_checking:
    description: "Enable strict host key checking"
    required: false
    default: "true"
outputs:
  success:
    description: "File transfer was successful"
    value: ${{ steps.transfer.outputs.success }}
  error:
    description: "An error occurred during file transfer"
    value: ${{ steps.transfer.outputs.error }}

runs:
  using: "composite"
  steps:
    - name: Setup SSH key and configuration
      shell: bash
      run: |
        # This ensures that the action stops if any part of it encounters an error
        set -e
        # Create SSH directory with correct permissions
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh

        # Generate a unique key filename to avoid conflicts with existing keys
        SSH_KEY_FILE="$HOME/.ssh/sshft_key_$(date +%s)_$RANDOM"
        SSH_CONFIG_FILE="$HOME/.ssh/sshft_config_$(date +%s)_$RANDOM"
        SSH_KNOWN_HOSTS="$HOME/.ssh/sshft_known_hosts_$(date +%s)_$RANDOM"

        # Export the key path for other steps to use
        echo "SSH_KEY_FILE=$SSH_KEY_FILE" >> $GITHUB_ENV
        echo "SSH_CONFIG_FILE=$SSH_CONFIG_FILE" >> $GITHUB_ENV
        echo "SSH_KNOWN_HOSTS=$SSH_KNOWN_HOSTS" >> $GITHUB_ENV

        # Save SSH key with proper permissions (before writing content)
        touch "$SSH_KEY_FILE"
        chmod 600 "$SSH_KEY_FILE"
        echo "${{ inputs.key }}" > "$SSH_KEY_FILE"

        # Verify the key is valid
        if ! ssh-keygen -l -f "$SSH_KEY_FILE" &>/dev/null; then
          echo "Error: The provided SSH key appears to be invalid"
          rm -f "$SSH_KEY_FILE"
          exit 1
        fi

        # Create SSH config with appropriate security settings
        printf "Host %s\nPort %s\nUser %s\nIdentityFile %s\nBatchMode yes\nConnectTimeout 30\nServerAliveInterval 60\nServerAliveCountMax 10\n" "${{ inputs.host }}" "${{ inputs.port }}" "${{ inputs.username }}" "$SSH_KEY_FILE" > "$SSH_CONFIG_FILE"

        # Configure host key checking based on input
        if [ "${{ inputs.strict_host_key_checking }}" = "false" ]; then
          echo "  StrictHostKeyChecking no" >> "$SSH_CONFIG_FILE"
          echo "  UserKnownHostsFile=/dev/null" >> "$SSH_CONFIG_FILE"
        else
          # First try to scan the host key
          touch "$SSH_KNOWN_HOSTS"
          chmod 600 "$SSH_KNOWN_HOSTS"
          ssh-keyscan -p ${{ inputs.port }} -H ${{ inputs.host }} >> "$SSH_KNOWN_HOSTS" 2>/dev/null || true
          echo "  StrictHostKeyChecking yes" >> "$SSH_CONFIG_FILE"
          echo "  UserKnownHostsFile=$SSH_KNOWN_HOSTS" >> "$SSH_CONFIG_FILE"
        fi

        chmod 600 "$SSH_CONFIG_FILE"

        # Handle SSH key passphrase if provided
        if [ -n "${{ inputs.passphrase }}" ]; then
          eval $(ssh-agent -s)
          echo "${{ inputs.passphrase }}" | ssh-add "$SSH_KEY_FILE"
        fi

    - name: Verify SSH connection
      shell: bash
      run: |
        if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "echo SSH connection successful"; then
          echo "Error: Failed to establish SSH connection"
          exit 1
        fi

    - name: Transfer files
      shell: bash
      id: transfer
      run: |
        set -e
        echo "Starting file transfer..."

        # Create temp directory for operations
        TEMP_DIR=$(mktemp -d)
        # Set cleanup trap for unexpected exits
        cleanup() {
          echo "Cleaning up temporary files..."
          rm -rf "$TEMP_DIR" 2>/dev/null || true
          ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "rm -rf ~/temp_sshft_*.tar.gz" 2>/dev/null || true
        }
        trap cleanup EXIT

        # Get the base name of the source path for the tar.gz file
        SOURCE_PATH="${{ inputs.source }}"
        if [[ "$SOURCE_PATH" == */ ]]; then
          SOURCE_PATH="${SOURCE_PATH%/}"
        fi
        BASE_NAME=$(basename "$SOURCE_PATH")
        TAR_FILE="temp_sshft_${BASE_NAME}.tar.gz"

        # Check if the source exists
        if [ ! -e "$SOURCE_PATH" ]; then
          echo "Error: Source file or directory does not exist: $SOURCE_PATH"
          exit 1
        fi

        if [[ "${{ inputs.direction }}" == "upload" ]]; then
          # UPLOAD: Local -> Remote
          echo "Compressing source files locally..."
          if [ -d "$SOURCE_PATH" ]; then
            # If source is a directory, compress its contents
            tar -czf "$TEMP_DIR/$TAR_FILE" -C "$(dirname "$SOURCE_PATH")" "$(basename "$SOURCE_PATH")"
          else
            # If source is a file
            tar -czf "$TEMP_DIR/$TAR_FILE" -C "$(dirname "$SOURCE_PATH")" "$(basename "$SOURCE_PATH")"
          fi
          
          # Transfer the compressed file to remote server
          echo "Transferring compressed file to remote server..."
          if ! scp -F "$SSH_CONFIG_FILE" "$TEMP_DIR/$TAR_FILE" ${{ inputs.host }}:~/"$TAR_FILE"; then
            echo "Error: Failed to transfer compressed file to remote server"
            echo "error=File transfer failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Verify destination directory exists and is writable
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "[ -d \"${{ inputs.destination }}\" ] && [ -w \"${{ inputs.destination }}\" ]"; then
            echo "Error: Destination directory does not exist or is not writable"
            echo "error=Destination directory issue" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Extract on remote and move to destination
          # Fix: Pre-calculate the basename locally and use it in the remote command
          BASENAME_SOURCE=$(basename "$SOURCE_PATH")
          echo "Extracting files on remote server..."
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "mkdir -p ~/temp_extract && tar -xzf ~/$TAR_FILE -C ~/temp_extract && cp -r ~/temp_extract/$BASENAME_SOURCE/* \"${{ inputs.destination }}/\" && rm -rf ~/temp_extract ~/$TAR_FILE"; then
            echo "Error: Failed to extract files on remote server"
            echo "error=Remote extraction failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
        else
          # DOWNLOAD: Remote -> Local
          # Verify remote source exists
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "[ -e \"${{ inputs.source }}\" ]"; then
            echo "Error: Remote source does not exist"
            echo "error=Remote source not found" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Compress on remote server
          echo "Compressing files on remote server..."
          REMOTE_SOURCE="${{ inputs.source }}"
          if [[ "$REMOTE_SOURCE" == */ ]]; then
            REMOTE_SOURCE="${REMOTE_SOURCE%/}"
          fi
          
          # Fix: Pre-calculate dirname and basename for the remote command
          REMOTE_DIR=$(dirname "$REMOTE_SOURCE")
          REMOTE_BASE=$(basename "$REMOTE_SOURCE")
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "tar -czf ~/$TAR_FILE -C \"$REMOTE_DIR\" \"$REMOTE_BASE\""; then
            echo "Error: Failed to compress files on remote server"
            echo "error=Remote compression failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Download the compressed file
          echo "Downloading compressed file..."
          if ! scp -F "$SSH_CONFIG_FILE" ${{ inputs.host }}:~/"$TAR_FILE" "$TEMP_DIR/$TAR_FILE"; then
            echo "Error: Failed to download compressed file"
            echo "error=Download failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Create destination directory if it doesn't exist
          mkdir -p "${{ inputs.destination }}"
          
          # Extract locally
          # Fix: Use pre-calculated basename
          echo "Extracting files locally..."
          if ! tar -xzf "$TEMP_DIR/$TAR_FILE" -C "$TEMP_DIR" && cp -r "$TEMP_DIR/$REMOTE_BASE"/* "${{ inputs.destination }}/"; then
            echo "Error: Failed to extract files locally"
            echo "error=Local extraction failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Clean up remote temporary file
          ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "rm -f ~/$TAR_FILE" || true
        fi

        echo "File transfer completed successfully"
        echo "success=true" >> $GITHUB_OUTPUT

        # Cleanup is handled by the trap

    - name: Cleanup SSH files securely
      shell: bash
      if: always()
      run: |
        # Terminate any ssh-agent process
        if [ -n "$SSH_AGENT_PID" ]; then
          ssh-agent -k || true
        fi

        # Securely remove SSH files
        if [ -f "$SSH_KEY_FILE" ]; then
          # Overwrite with zeros before deleting
          dd if=/dev/zero of="$SSH_KEY_FILE" bs=1k count=1 conv=notrunc >/dev/null 2>&1 || true
          rm -f "$SSH_KEY_FILE"
        fi

        # Remove other temporary SSH files
        rm -f "$SSH_CONFIG_FILE"
        rm -f "$SSH_KNOWN_HOSTS"

branding:
  icon: "upload-cloud"
  color: "blue"
