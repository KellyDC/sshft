name: "Secure File Transfer"
description: "A GitHub Action to securely transfer files over SSH using SCP with support for upload and download directions."
author: "KellyDC"
inputs:
  host:
    description: "SSH host to connect to"
    required: true
  port:
    description: "SSH port"
    required: false
    default: "22"
  username:
    description: "SSH username"
    required: true
  key:
    description: "SSH private key"
    required: true
  passphrase:
    description: "Passphrase for the SSH private key"
    required: false
  source:
    description: "Source file or directory to transfer"
    required: true
  destination:
    description: "Destination path on the remote server"
    required: true
  direction:
    description: "Transfer direction"
    required: false
    default: "upload"
  recursive:
    description: "Transfer files recursively"
    required: false
    default: "true"
  strict_host_key_checking:
    description: "Enable strict host key checking"
    required: false
    default: "true"
outputs:
  success:
    description: "File transfer was successful"
    value: ${{ steps.transfer.outputs.success }}
  error:
    description: "An error occurred during file transfer"
    value: ${{ steps.transfer.outputs.error }}

runs:
  using: "composite"
  steps:
    - name: Setup SSH key and configuration
      shell: bash
      run: |
        # This ensures that the action stops if any part of it encounters an error
        set -e
        # Create SSH directory with correct permissions
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh

        # Generate a unique key filename to avoid conflicts with existing keys
        SSH_KEY_FILE="$HOME/.ssh/sshft_key_$(date +%s)_$RANDOM"
        SSH_CONFIG_FILE="$HOME/.ssh/sshft_config_$(date +%s)_$RANDOM"
        SSH_KNOWN_HOSTS="$HOME/.ssh/sshft_known_hosts_$(date +%s)_$RANDOM"

        # Export the key path for other steps to use
        echo "SSH_KEY_FILE=$SSH_KEY_FILE" >> $GITHUB_ENV
        echo "SSH_CONFIG_FILE=$SSH_CONFIG_FILE" >> $GITHUB_ENV
        echo "SSH_KNOWN_HOSTS=$SSH_KNOWN_HOSTS" >> $GITHUB_ENV

        # Save SSH key with proper permissions (before writing content)
        touch "$SSH_KEY_FILE"
        chmod 600 "$SSH_KEY_FILE"
        echo "${{ inputs.key }}" > "$SSH_KEY_FILE"

        # Verify the key is valid
        if ! ssh-keygen -l -f "$SSH_KEY_FILE" &>/dev/null; then
          echo "Error: The provided SSH key appears to be invalid"
          rm -f "$SSH_KEY_FILE"
          exit 1
        fi

        # Create SSH config with appropriate security settings
        printf "Host %s\nPort %s\nUser %s\nIdentityFile %s\nBatchMode yes\nConnectTimeout 30\nServerAliveInterval 60\nServerAliveCountMax 10\n" "${{ inputs.host }}" "${{ inputs.port }}" "${{ inputs.username }}" "$SSH_KEY_FILE" > "$SSH_CONFIG_FILE"

        # Configure host key checking based on input
        if [ "${{ inputs.strict_host_key_checking }}" = "false" ]; then
          echo "  StrictHostKeyChecking no" >> "$SSH_CONFIG_FILE"
          echo "  UserKnownHostsFile=/dev/null" >> "$SSH_CONFIG_FILE"
        else
          # First try to scan the host key
          touch "$SSH_KNOWN_HOSTS"
          chmod 600 "$SSH_KNOWN_HOSTS"
          ssh-keyscan -p ${{ inputs.port }} -H ${{ inputs.host }} >> "$SSH_KNOWN_HOSTS" 2>/dev/null || true
          echo "  StrictHostKeyChecking yes" >> "$SSH_CONFIG_FILE"
          echo "  UserKnownHostsFile=$SSH_KNOWN_HOSTS" >> "$SSH_CONFIG_FILE"
        fi

        chmod 600 "$SSH_CONFIG_FILE"

        # Handle SSH key passphrase if provided
        if [ -n "${{ inputs.passphrase }}" ]; then
          eval $(ssh-agent -s)
          echo "${{ inputs.passphrase }}" | ssh-add "$SSH_KEY_FILE"
        fi

    - name: Verify SSH connection
      shell: bash
      run: |
        if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "echo SSH connection successful"; then
          echo "Error: Failed to establish SSH connection"
          exit 1
        fi

    - name: Transfer files
      shell: bash
      id: transfer
      run: |
        set -e
        echo "Starting file transfer..."

        # Create temp directory for operations
        TEMP_DIR=$(mktemp -d)

        # Generate random string for unique temporary directories and files
        RANDOM_ID=$(openssl rand -hex 8)
        TIMESTAMP=$(date +%s)
        UNIQUE_SUFFIX="${TIMESTAMP}_${RANDOM_ID}"

        # Remote temporary directory path (using unique random name)
        REMOTE_TEMP_DIR="/tmp/sshft_temp_${UNIQUE_SUFFIX}"

        # Set cleanup trap for unexpected exits
        cleanup() {
          echo "Cleaning up temporary files..."
          # Clean up local temp directory
          rm -rf "$TEMP_DIR" 2>/dev/null || true
          # Clean up remote temp directory and any temp files
          ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "rm -rf \"$REMOTE_TEMP_DIR\" /tmp/sshft_*_${UNIQUE_SUFFIX}.tar.gz" 2>/dev/null || true
        }
        trap cleanup EXIT

        # Get the base name of the source path for the tar.gz file
        SOURCE_PATH="${{ inputs.source }}"
        if [[ "$SOURCE_PATH" == */ ]]; then
          SOURCE_PATH="${SOURCE_PATH%/}"
        fi
        BASE_NAME=$(basename "$SOURCE_PATH")
        TAR_FILE="sshft_${BASE_NAME}_${UNIQUE_SUFFIX}.tar.gz"

        # Check if the source exists
        if [ ! -e "$SOURCE_PATH" ]; then
          echo "Error: Source file or directory does not exist: $SOURCE_PATH"
          exit 1
        fi

        # Function to check if a file is already compressed
        is_compressed() {
          local file="$1"
          local mime_type
          local extension
          
          # Get file extension
          extension="${file##*.}"
          extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')
          
          # Check common compressed file extensions
          case "$extension" in
            gz|tgz|tar.gz|bz2|tbz2|tar.bz2|xz|txz|tar.xz|zip|rar|7z|tar|lz4|zst)
              return 0 ;;
          esac
          
          # Check MIME type if file command is available
          if command -v file >/dev/null 2>&1; then
            mime_type=$(file -b --mime-type "$file" 2>/dev/null || echo "")
            case "$mime_type" in
              application/gzip|application/x-gzip|application/x-tar|application/zip|application/x-rar|application/x-7z-compressed|application/x-bzip2|application/x-xz)
                return 0 ;;
            esac
          fi
          
          return 1
        }

        if [[ "${{ inputs.direction }}" == "upload" ]]; then
          # UPLOAD: Local -> Remote
          # Check if we need compression
          NEEDS_COMPRESSION=true
          TRANSFER_FILE=""
          
          if [ -f "$SOURCE_PATH" ] && is_compressed "$SOURCE_PATH"; then
            echo "Source file is already compressed, transferring directly..."
            NEEDS_COMPRESSION=false
            TRANSFER_FILE="$SOURCE_PATH"
          elif [ -d "$SOURCE_PATH" ]; then
            # Check if directory contains only compressed files
            COMPRESSED_COUNT=$(find "$SOURCE_PATH" -type f -exec sh -c 'case "${1##*.}" in gz|tgz|tar.gz|bz2|tbz2|tar.bz2|xz|txz|tar.xz|zip|rar|7z|tar|lz4|zst) exit 0;; *) exit 1;; esac' _ {} \; 2>/dev/null | wc -l || echo 0)
            TOTAL_FILES=$(find "$SOURCE_PATH" -type f | wc -l)
            
            if [ "$COMPRESSED_COUNT" -eq "$TOTAL_FILES" ] && [ "$TOTAL_FILES" -gt 0 ]; then
              echo "Directory contains only compressed files, compressing anyway for consistency..."
            fi
            
            echo "Compressing directory..."
            tar -czf "$TEMP_DIR/$TAR_FILE" -C "$(dirname "$SOURCE_PATH")" "$(basename "$SOURCE_PATH")"
            TRANSFER_FILE="$TEMP_DIR/$TAR_FILE"
          else
            echo "Compressing source file..."
            tar -czf "$TEMP_DIR/$TAR_FILE" -C "$(dirname "$SOURCE_PATH")" "$(basename "$SOURCE_PATH")"
            TRANSFER_FILE="$TEMP_DIR/$TAR_FILE"
          fi
          
          # Create remote temp directory
          echo "Creating remote temporary directory..."
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "mkdir -p \"$REMOTE_TEMP_DIR\""; then
            echo "Error: Failed to create remote temporary directory"
            echo "error=Remote temp dir creation failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Transfer the file to remote server
          echo "Transferring file to remote server..."
          if [ "$NEEDS_COMPRESSION" = true ]; then
            REMOTE_FILE="$REMOTE_TEMP_DIR/$TAR_FILE"
          else
            REMOTE_FILE="$REMOTE_TEMP_DIR/$(basename "$SOURCE_PATH")"
          fi
          
          if ! scp -F "$SSH_CONFIG_FILE" "$TRANSFER_FILE" "${{ inputs.host }}:$REMOTE_FILE"; then
            echo "Error: Failed to transfer file to remote server"
            echo "error=File transfer failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Verify destination directory exists and is writable
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "[ -d \"${{ inputs.destination }}\" ] && [ -w \"${{ inputs.destination }}\" ]"; then
            echo "Error: Destination directory does not exist or is not writable"
            echo "error=Destination directory issue" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Extract/move files on remote server
          BASENAME_SOURCE=$(basename "$SOURCE_PATH")
          if [ "$NEEDS_COMPRESSION" = true ]; then
            echo "Extracting files on remote server..."
            if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "cd \"$REMOTE_TEMP_DIR\" && tar -xzf \"$TAR_FILE\" && cp -r \"$BASENAME_SOURCE\"/* \"${{ inputs.destination }}/\""; then
              echo "Error: Failed to extract files on remote server"
              echo "error=Remote extraction failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "Moving compressed file to destination..."
            if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "cp \"$REMOTE_FILE\" \"${{ inputs.destination }}/\""; then
              echo "Error: Failed to move file to destination"
              echo "error=Remote file move failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
        else
          # DOWNLOAD: Remote -> Local
          # Verify remote source exists
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "[ -e \"${{ inputs.source }}\" ]"; then
            echo "Error: Remote source does not exist"
            echo "error=Remote source not found" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Create remote temp directory
          echo "Creating remote temporary directory..."
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "mkdir -p \"$REMOTE_TEMP_DIR\""; then
            echo "Error: Failed to create remote temporary directory"
            echo "error=Remote temp dir creation failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          REMOTE_SOURCE="${{ inputs.source }}"
          if [[ "$REMOTE_SOURCE" == */ ]]; then
            REMOTE_SOURCE="${REMOTE_SOURCE%/}"
          fi
          
          REMOTE_DIR=$(dirname "$REMOTE_SOURCE")
          REMOTE_BASE=$(basename "$REMOTE_SOURCE")
          NEEDS_COMPRESSION=true
          DOWNLOAD_FILE=""
          
          # Check if source is a single compressed file
          if ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "[ -f \"$REMOTE_SOURCE\" ]"; then
            # Check if it's compressed by extension
            case "${REMOTE_BASE##*.}" in
              gz|tgz|tar.gz|bz2|tbz2|tar.bz2|xz|txz|tar.xz|zip|rar|7z|tar|lz4|zst)
                echo "Remote source is already compressed, downloading directly..."
                NEEDS_COMPRESSION=false
                DOWNLOAD_FILE="$REMOTE_TEMP_DIR/$REMOTE_BASE"
                # Copy file to temp directory
                if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "cp \"$REMOTE_SOURCE\" \"$DOWNLOAD_FILE\""; then
                  echo "Error: Failed to copy remote file to temp directory"
                  echo "error=Remote file copy failed" >> $GITHUB_OUTPUT
                  exit 1
                fi
                ;;
              *)
                echo "Compressing single file on remote server..."
                DOWNLOAD_FILE="$REMOTE_TEMP_DIR/$TAR_FILE"
                if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "tar -czf \"$DOWNLOAD_FILE\" -C \"$REMOTE_DIR\" \"$REMOTE_BASE\""; then
                  echo "Error: Failed to compress file on remote server"
                  echo "error=Remote compression failed" >> $GITHUB_OUTPUT
                  exit 1
                fi
                ;;
            esac
          else
            # Directory - always compress for consistency
            echo "Compressing directory on remote server..."
            DOWNLOAD_FILE="$REMOTE_TEMP_DIR/$TAR_FILE"
            if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "tar -czf \"$DOWNLOAD_FILE\" -C \"$REMOTE_DIR\" \"$REMOTE_BASE\""; then
              echo "Error: Failed to compress directory on remote server"
              echo "error=Remote compression failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
          # Download the file
          echo "Downloading file from remote server..."
          LOCAL_DOWNLOAD_FILE="$TEMP_DIR/$(basename "$DOWNLOAD_FILE")"
          if ! scp -F "$SSH_CONFIG_FILE" "${{ inputs.host }}:$DOWNLOAD_FILE" "$LOCAL_DOWNLOAD_FILE"; then
            echo "Error: Failed to download file"
            echo "error=Download failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Create destination directory if it doesn't exist
          mkdir -p "${{ inputs.destination }}"
          
          # Extract/move files locally
          if [ "$NEEDS_COMPRESSION" = true ]; then
            echo "Extracting files locally..."
            if ! tar -xzf "$LOCAL_DOWNLOAD_FILE" -C "$TEMP_DIR"; then
              echo "Error: Failed to extract files locally"
              echo "error=Local extraction failed" >> $GITHUB_OUTPUT
              exit 1
            fi
            # Copy extracted content to destination
            if ! cp -r "$TEMP_DIR/$REMOTE_BASE"/* "${{ inputs.destination }}/"; then
              echo "Error: Failed to copy extracted files to destination"
              echo "error=Local copy failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "Moving downloaded compressed file to destination..."
            if ! cp "$LOCAL_DOWNLOAD_FILE" "${{ inputs.destination }}/"; then
              echo "Error: Failed to move downloaded file to destination"
              echo "error=Local file move failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
        fi

        echo "File transfer completed successfully"
        echo "success=true" >> $GITHUB_OUTPUT

        # Manual cleanup (trap will also run)
        echo "Cleaning up temporary files..."
        rm -rf "$TEMP_DIR" 2>/dev/null || true
        ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "rm -rf \"$REMOTE_TEMP_DIR\"" 2>/dev/null || true

    - name: Cleanup SSH files securely
      shell: bash
      if: always()
      run: |
        # Terminate any ssh-agent process
        if [ -n "$SSH_AGENT_PID" ]; then
          ssh-agent -k || true
        fi

        # Securely remove SSH files
        if [ -f "$SSH_KEY_FILE" ]; then
          # Overwrite with zeros before deleting
          dd if=/dev/zero of="$SSH_KEY_FILE" bs=1k count=1 conv=notrunc >/dev/null 2>&1 || true
          rm -f "$SSH_KEY_FILE"
        fi

        # Remove other temporary SSH files
        rm -f "$SSH_CONFIG_FILE"
        rm -f "$SSH_KNOWN_HOSTS"

branding:
  icon: "upload-cloud"
  color: "blue"
