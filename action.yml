name: "Secure File Transfer"
description: "A GitHub Action to securely transfer files over SSH using SCP with support for upload and download directions."
author: "KellyDC"
inputs:
  host:
    description: "SSH host to connect to"
    required: true
  port:
    description: "SSH port"
    required: false
    default: "22"
  username:
    description: "SSH username"
    required: true
  key:
    description: "SSH private key"
    required: true
  passphrase:
    description: "Passphrase for the SSH private key"
    required: false
  source:
    description: "Source file or directory to transfer"
    required: true
  destination:
    description: "Destination path on the remote server"
    required: true
  direction:
    description: "Transfer direction"
    required: false
    default: "upload"
  recursive:
    description: "Transfer files recursively"
    required: false
    default: "true"
  strict_host_key_checking:
    description: "Enable strict host key checking"
    required: false
    default: "true"
  post_script:
    description: "Optional inline script to run on the remote server after file transfer completes"
    required: false
  post_script_path:
    description: "Optional path to a script on the remote server to run after file transfer completes"
    required: false
outputs:
  success:
    description: "File transfer was successful"
    value: ${{ steps.transfer.outputs.success }}
  error:
    description: "An error occurred during file transfer"
    value: ${{ steps.transfer.outputs.error }}
  script_executed:
    description: "Whether a post-transfer script was executed"
    value: ${{ steps.post_script.outputs.executed }}
  script_output:
    description: "Output from the post-transfer script execution"
    value: ${{ steps.post_script.outputs.output }}
  script_error:
    description: "Error message if script execution failed"
    value: ${{ steps.post_script.outputs.error }}

runs:
  using: "composite"
  steps:
    - name: Setup SSH key and configuration
      shell: bash
      run: |
        # This ensures that the action stops if any part of it encounters an error
        set -e
        # Create SSH directory with correct permissions
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh

        # Generate a unique key filename to avoid conflicts with existing keys
        SSH_KEY_FILE="$HOME/.ssh/sshft_key_$(date +%s)_$RANDOM"
        SSH_CONFIG_FILE="$HOME/.ssh/sshft_config_$(date +%s)_$RANDOM"
        SSH_KNOWN_HOSTS="$HOME/.ssh/sshft_known_hosts_$(date +%s)_$RANDOM"

        # Export the key path for other steps to use
        echo "SSH_KEY_FILE=$SSH_KEY_FILE" >> $GITHUB_ENV
        echo "SSH_CONFIG_FILE=$SSH_CONFIG_FILE" >> $GITHUB_ENV
        echo "SSH_KNOWN_HOSTS=$SSH_KNOWN_HOSTS" >> $GITHUB_ENV

        # Save SSH key with proper permissions (before writing content)
        touch "$SSH_KEY_FILE"
        chmod 600 "$SSH_KEY_FILE"
        echo "${{ inputs.key }}" > "$SSH_KEY_FILE"

        # Verify the key is valid
        if ! ssh-keygen -l -f "$SSH_KEY_FILE" &>/dev/null; then
          echo "Error: The provided SSH key appears to be invalid"
          rm -f "$SSH_KEY_FILE"
          exit 1
        fi

        # Create SSH config with appropriate security settings
        printf "Host %s\nPort %s\nUser %s\nIdentityFile %s\nBatchMode yes\nConnectTimeout 30\nServerAliveInterval 60\nServerAliveCountMax 10\n" "${{ inputs.host }}" "${{ inputs.port }}" "${{ inputs.username }}" "$SSH_KEY_FILE" > "$SSH_CONFIG_FILE"

        # Configure host key checking based on input
        if [ "${{ inputs.strict_host_key_checking }}" = "false" ]; then
          echo "  StrictHostKeyChecking no" >> "$SSH_CONFIG_FILE"
          echo "  UserKnownHostsFile=/dev/null" >> "$SSH_CONFIG_FILE"
        else
          # First try to scan the host key
          touch "$SSH_KNOWN_HOSTS"
          chmod 600 "$SSH_KNOWN_HOSTS"
          ssh-keyscan -p ${{ inputs.port }} -H ${{ inputs.host }} >> "$SSH_KNOWN_HOSTS" 2>/dev/null || true
          echo "  StrictHostKeyChecking yes" >> "$SSH_CONFIG_FILE"
          echo "  UserKnownHostsFile=$SSH_KNOWN_HOSTS" >> "$SSH_CONFIG_FILE"
        fi

        chmod 600 "$SSH_CONFIG_FILE"

        # Handle SSH key passphrase if provided
        if [ -n "${{ inputs.passphrase }}" ]; then
          eval $(ssh-agent -s)
          echo "${{ inputs.passphrase }}" | ssh-add "$SSH_KEY_FILE"
        fi

    - name: Verify SSH connection
      shell: bash
      run: |
        if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "echo SSH connection successful"; then
          echo "Error: Failed to establish SSH connection"
          exit 1
        fi

    - name: Transfer files
      shell: bash
      id: transfer
      run: |
        set -e
        echo "Starting file transfer..."

        # Create temp directory for operations
        TEMP_DIR=$(mktemp -d)

        # Generate random string for unique temporary directories and files
        RANDOM_ID=$(openssl rand -hex 8)
        TIMESTAMP=$(date +%s)
        UNIQUE_SUFFIX="${TIMESTAMP}_${RANDOM_ID}"

        # Remote temporary directory path (using unique random name)
        REMOTE_TEMP_DIR="/tmp/sshft_temp_${UNIQUE_SUFFIX}"

        # Set cleanup trap for unexpected exits
        cleanup() {
          echo "Cleaning up temporary files..."
          # Clean up local temp directory
          rm -rf "$TEMP_DIR" 2>/dev/null || true
          # Clean up remote temp directory and any temp files
          ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "rm -rf \"$REMOTE_TEMP_DIR\" /tmp/sshft_*_${UNIQUE_SUFFIX}.tar.gz" 2>/dev/null || true
        }
        trap cleanup EXIT

        # Get the base name of the source path for the tar.gz file
        SOURCE_PATH="${{ inputs.source }}"
        if [[ "$SOURCE_PATH" == */ ]]; then
          SOURCE_PATH="${SOURCE_PATH%/}"
        fi
        BASE_NAME=$(basename "$SOURCE_PATH")
        TAR_FILE="sshft_${BASE_NAME}_${UNIQUE_SUFFIX}.tar.gz"

        # Check if the source exists
        if [ ! -e "$SOURCE_PATH" ]; then
          echo "Error: Source file or directory does not exist: $SOURCE_PATH"
          exit 1
        fi

        # Function to check if a file is already compressed
        is_compressed() {
          local file="$1"
          local mime_type
          local extension
          
          # Get file extension
          extension="${file##*.}"
          extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')
          
          # Check common compressed file extensions
          case "$extension" in
            gz|tgz|tar.gz|bz2|tbz2|tar.bz2|xz|txz|tar.xz|zip|rar|7z|tar|lz4|zst)
              return 0 ;;
          esac
          
          # Check MIME type if file command is available
          if command -v file >/dev/null 2>&1; then
            mime_type=$(file -b --mime-type "$file" 2>/dev/null || echo "")
            case "$mime_type" in
              application/gzip|application/x-gzip|application/x-tar|application/zip|application/x-rar|application/x-7z-compressed|application/x-bzip2|application/x-xz)
                return 0 ;;
            esac
          fi
          
          return 1
        }

        if [[ "${{ inputs.direction }}" == "upload" ]]; then
          # UPLOAD: Local -> Remote
          # Check if we need compression
          NEEDS_COMPRESSION=true
          TRANSFER_FILE=""
          
          if [ -f "$SOURCE_PATH" ] && is_compressed "$SOURCE_PATH"; then
            echo "Source file is already compressed, transferring directly..."
            NEEDS_COMPRESSION=false
            TRANSFER_FILE="$SOURCE_PATH"
          elif [ -d "$SOURCE_PATH" ]; then
            # Check if directory contains only compressed files
            COMPRESSED_COUNT=$(find "$SOURCE_PATH" -type f -exec sh -c 'case "${1##*.}" in gz|tgz|tar.gz|bz2|tbz2|tar.bz2|xz|txz|tar.xz|zip|rar|7z|tar|lz4|zst) exit 0;; *) exit 1;; esac' _ {} \; 2>/dev/null | wc -l || echo 0)
            TOTAL_FILES=$(find "$SOURCE_PATH" -type f | wc -l)
            
            if [ "$COMPRESSED_COUNT" -eq "$TOTAL_FILES" ] && [ "$TOTAL_FILES" -gt 0 ]; then
              echo "Directory contains only compressed files, compressing anyway for consistency..."
            fi
            
            echo "Compressing directory..."
            tar -czf "$TEMP_DIR/$TAR_FILE" -C "$(dirname "$SOURCE_PATH")" "$(basename "$SOURCE_PATH")"
            TRANSFER_FILE="$TEMP_DIR/$TAR_FILE"
          else
            echo "Compressing source file..."
            tar -czf "$TEMP_DIR/$TAR_FILE" -C "$(dirname "$SOURCE_PATH")" "$(basename "$SOURCE_PATH")"
            TRANSFER_FILE="$TEMP_DIR/$TAR_FILE"
          fi
          
          # Create remote temp directory
          echo "Creating remote temporary directory..."
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "mkdir -p \"$REMOTE_TEMP_DIR\""; then
            echo "Error: Failed to create remote temporary directory"
            echo "error=Remote temp dir creation failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Transfer the file to remote server
          echo "Transferring file to remote server..."
          if [ "$NEEDS_COMPRESSION" = true ]; then
            REMOTE_FILE="$REMOTE_TEMP_DIR/$TAR_FILE"
          else
            REMOTE_FILE="$REMOTE_TEMP_DIR/$(basename "$SOURCE_PATH")"
          fi
          
          if ! scp -F "$SSH_CONFIG_FILE" "$TRANSFER_FILE" "${{ inputs.host }}:$REMOTE_FILE"; then
            echo "Error: Failed to transfer file to remote server"
            echo "error=File transfer failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Verify destination directory exists and is writable
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "[ -d \"${{ inputs.destination }}\" ] && [ -w \"${{ inputs.destination }}\" ]"; then
            echo "Error: Destination directory does not exist or is not writable"
            echo "error=Destination directory issue" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Extract/move files on remote server
          BASENAME_SOURCE=$(basename "$SOURCE_PATH")
          if [ "$NEEDS_COMPRESSION" = true ]; then
            echo "Extracting files on remote server..."
            if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "cd \"$REMOTE_TEMP_DIR\" && tar -xzf \"$TAR_FILE\" && cp -r \"$BASENAME_SOURCE\"/* \"${{ inputs.destination }}/\""; then
              echo "Error: Failed to extract files on remote server"
              echo "error=Remote extraction failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "Moving compressed file to destination..."
            if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "cp \"$REMOTE_FILE\" \"${{ inputs.destination }}/\""; then
              echo "Error: Failed to move file to destination"
              echo "error=Remote file move failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
        else
          # DOWNLOAD: Remote -> Local
          # Verify remote source exists
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "[ -e \"${{ inputs.source }}\" ]"; then
            echo "Error: Remote source does not exist"
            echo "error=Remote source not found" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Create remote temp directory
          echo "Creating remote temporary directory..."
          if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "mkdir -p \"$REMOTE_TEMP_DIR\""; then
            echo "Error: Failed to create remote temporary directory"
            echo "error=Remote temp dir creation failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          REMOTE_SOURCE="${{ inputs.source }}"
          if [[ "$REMOTE_SOURCE" == */ ]]; then
            REMOTE_SOURCE="${REMOTE_SOURCE%/}"
          fi
          
          REMOTE_DIR=$(dirname "$REMOTE_SOURCE")
          REMOTE_BASE=$(basename "$REMOTE_SOURCE")
          NEEDS_COMPRESSION=true
          DOWNLOAD_FILE=""
          
          # Check if source is a single compressed file
          if ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "[ -f \"$REMOTE_SOURCE\" ]"; then
            # Check if it's compressed by extension
            case "${REMOTE_BASE##*.}" in
              gz|tgz|tar.gz|bz2|tbz2|tar.bz2|xz|txz|tar.xz|zip|rar|7z|tar|lz4|zst)
                echo "Remote source is already compressed, downloading directly..."
                NEEDS_COMPRESSION=false
                DOWNLOAD_FILE="$REMOTE_TEMP_DIR/$REMOTE_BASE"
                # Copy file to temp directory
                if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "cp \"$REMOTE_SOURCE\" \"$DOWNLOAD_FILE\""; then
                  echo "Error: Failed to copy remote file to temp directory"
                  echo "error=Remote file copy failed" >> $GITHUB_OUTPUT
                  exit 1
                fi
                ;;
              *)
                echo "Compressing single file on remote server..."
                DOWNLOAD_FILE="$REMOTE_TEMP_DIR/$TAR_FILE"
                if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "tar -czf \"$DOWNLOAD_FILE\" -C \"$REMOTE_DIR\" \"$REMOTE_BASE\""; then
                  echo "Error: Failed to compress file on remote server"
                  echo "error=Remote compression failed" >> $GITHUB_OUTPUT
                  exit 1
                fi
                ;;
            esac
          else
            # Directory - always compress for consistency
            echo "Compressing directory on remote server..."
            DOWNLOAD_FILE="$REMOTE_TEMP_DIR/$TAR_FILE"
            if ! ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "tar -czf \"$DOWNLOAD_FILE\" -C \"$REMOTE_DIR\" \"$REMOTE_BASE\""; then
              echo "Error: Failed to compress directory on remote server"
              echo "error=Remote compression failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
          # Download the file
          echo "Downloading file from remote server..."
          LOCAL_DOWNLOAD_FILE="$TEMP_DIR/$(basename "$DOWNLOAD_FILE")"
          if ! scp -F "$SSH_CONFIG_FILE" "${{ inputs.host }}:$DOWNLOAD_FILE" "$LOCAL_DOWNLOAD_FILE"; then
            echo "Error: Failed to download file"
            echo "error=Download failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Create destination directory if it doesn't exist
          mkdir -p "${{ inputs.destination }}"
          
          # Extract/move files locally
          if [ "$NEEDS_COMPRESSION" = true ]; then
            echo "Extracting files locally..."
            if ! tar -xzf "$LOCAL_DOWNLOAD_FILE" -C "$TEMP_DIR"; then
              echo "Error: Failed to extract files locally"
              echo "error=Local extraction failed" >> $GITHUB_OUTPUT
              exit 1
            fi
            # Copy extracted content to destination
            if ! cp -r "$TEMP_DIR/$REMOTE_BASE"/* "${{ inputs.destination }}/"; then
              echo "Error: Failed to copy extracted files to destination"
              echo "error=Local copy failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "Moving downloaded compressed file to destination..."
            if ! cp "$LOCAL_DOWNLOAD_FILE" "${{ inputs.destination }}/"; then
              echo "Error: Failed to move downloaded file to destination"
              echo "error=Local file move failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
        fi

        echo "File transfer completed successfully"
        echo "success=true" >> $GITHUB_OUTPUT

        # Manual cleanup (trap will also run)
        echo "Cleaning up temporary files..."
        rm -rf "$TEMP_DIR" 2>/dev/null || true
        ssh -F "$SSH_CONFIG_FILE" ${{ inputs.host }} "rm -rf \"$REMOTE_TEMP_DIR\"" 2>/dev/null || true

    - name: Execute post-transfer script
      shell: bash
      id: post_script
      if: success() && (inputs.post_script != '' || inputs.post_script_path != '')
      run: |
        set +e  # Don't fail immediately on errors for this step
        echo "executed=false" >> $GITHUB_OUTPUT
        echo "error=" >> $GITHUB_OUTPUT
        echo "output=" >> $GITHUB_OUTPUT

        # Generate random ID for temporary script file
        RANDOM_ID=$(openssl rand -hex 8)
        TIMESTAMP=$(date +%s)
        TEMP_SCRIPT="/tmp/sshft_script_${TIMESTAMP}_${RANDOM_ID}.sh"

        # Cleanup function for script execution
        cleanup_script() {
          ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "rm -f \"$TEMP_SCRIPT\"" 2>/dev/null || true
        }
        trap cleanup_script EXIT

        # Determine which script to execute
        if [ -n "${{ inputs.post_script }}" ]; then
          echo "Executing inline post-transfer script..."
          
          # Validate that the script is not empty after trimming
          TRIMMED_SCRIPT=$(echo "${{ inputs.post_script }}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          if [ -z "$TRIMMED_SCRIPT" ]; then
            echo "Error: Inline script is empty or contains only whitespace"
            echo "error=Script is empty or malformed" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Basic validation: check for common shell script issues
          if ! echo "${{ inputs.post_script }}" | grep -qE '(^|[[:space:]])([a-zA-Z_][a-zA-Z0-9_]*=|if|then|else|fi|for|while|do|done|case|esac|function|echo|cd|ls|mkdir|rm|cp|mv)'; then
            echo "Warning: Script appears malformed (no recognizable shell commands found)"
            echo "error=Script appears malformed" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Create temporary script file locally first
          LOCAL_TEMP_SCRIPT=$(mktemp)
          echo '#!/bin/bash' > "$LOCAL_TEMP_SCRIPT"
          echo 'set -e' >> "$LOCAL_TEMP_SCRIPT"
          echo "${{ inputs.post_script }}" >> "$LOCAL_TEMP_SCRIPT"
          chmod +x "$LOCAL_TEMP_SCRIPT"
          
          # Upload script to remote server
          if ! scp -F "$SSH_CONFIG_FILE" "$LOCAL_TEMP_SCRIPT" "${{ inputs.host }}:$TEMP_SCRIPT" 2>&1; then
            echo "Error: Failed to upload script to remote server"
            echo "error=Failed to upload script file" >> $GITHUB_OUTPUT
            rm -f "$LOCAL_TEMP_SCRIPT"
            exit 0
          fi
          
          # Make script executable on remote
          if ! ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "chmod +x \"$TEMP_SCRIPT\"" 2>&1; then
            echo "Error: Failed to make script executable on remote server"
            echo "error=Failed to set script permissions" >> $GITHUB_OUTPUT
            rm -f "$LOCAL_TEMP_SCRIPT"
            exit 0
          fi
          
          rm -f "$LOCAL_TEMP_SCRIPT"
          
          # Execute the script and capture output
          SCRIPT_OUTPUT=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "\"$TEMP_SCRIPT\"" 2>&1) || SCRIPT_EXIT_CODE=$?
          
          if [ -n "$SCRIPT_EXIT_CODE" ] && [ "$SCRIPT_EXIT_CODE" -ne 0 ]; then
            echo "Error: Script execution failed with exit code $SCRIPT_EXIT_CODE"
            echo "error=Script execution failed" >> $GITHUB_OUTPUT
            echo "$SCRIPT_OUTPUT"
            exit 0
          fi
          
          echo "executed=true" >> $GITHUB_OUTPUT
          # Sanitize output for GitHub Actions (remove special characters that might break output)
          SANITIZED_OUTPUT=$(echo "$SCRIPT_OUTPUT" | tr -d '\000-\010\013\014\016-\037' | head -c 10000)
          echo "output<<SSHFT_OUTPUT_EOF" >> $GITHUB_OUTPUT
          echo "$SANITIZED_OUTPUT" >> $GITHUB_OUTPUT
          echo "SSHFT_OUTPUT_EOF" >> $GITHUB_OUTPUT
          echo "Inline script executed successfully"
          
        elif [ -n "${{ inputs.post_script_path }}" ]; then
          echo "Executing script from remote server path: ${{ inputs.post_script_path }}"
          
          # Check if the script file exists on remote server
          if ! ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "test -f \"${{ inputs.post_script_path }}\"" 2>&1; then
            echo "Error: Script file does not exist at path: ${{ inputs.post_script_path }}"
            echo "error=Script file does not exist" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if the script file is readable
          if ! ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "test -r \"${{ inputs.post_script_path }}\"" 2>&1; then
            echo "Error: Script file is not readable: ${{ inputs.post_script_path }}"
            echo "error=Script file is not readable" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Validate script syntax (basic check for bash scripts)
          SYNTAX_CHECK=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "bash -n \"${{ inputs.post_script_path }}\"" 2>&1) || SYNTAX_ERROR=$?
          
          if [ -n "$SYNTAX_ERROR" ] && [ "$SYNTAX_ERROR" -ne 0 ]; then
            echo "Error: Script has syntax errors"
            echo "error=Script is malformed (syntax errors)" >> $GITHUB_OUTPUT
            echo "$SYNTAX_CHECK"
            exit 0
          fi
          
          # Check if the script is executable, if not try to execute with bash
          if ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "test -x \"${{ inputs.post_script_path }}\"" 2>&1; then
            # Script is executable, run it directly
            SCRIPT_OUTPUT=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "\"${{ inputs.post_script_path }}\"" 2>&1) || SCRIPT_EXIT_CODE=$?
          else
            # Script is not executable, run with bash
            echo "Note: Script is not executable, running with bash interpreter"
            SCRIPT_OUTPUT=$(ssh -F "$SSH_CONFIG_FILE" "${{ inputs.host }}" "bash \"${{ inputs.post_script_path }}\"" 2>&1) || SCRIPT_EXIT_CODE=$?
          fi
          
          if [ -n "$SCRIPT_EXIT_CODE" ] && [ "$SCRIPT_EXIT_CODE" -ne 0 ]; then
            echo "Error: Script execution failed with exit code $SCRIPT_EXIT_CODE"
            echo "error=Script execution failed" >> $GITHUB_OUTPUT
            echo "$SCRIPT_OUTPUT"
            exit 0
          fi
          
          echo "executed=true" >> $GITHUB_OUTPUT
          # Sanitize output for GitHub Actions (remove special characters that might break output)
          SANITIZED_OUTPUT=$(echo "$SCRIPT_OUTPUT" | tr -d '\000-\010\013\014\016-\037' | head -c 10000)
          echo "output<<SSHFT_OUTPUT_EOF" >> $GITHUB_OUTPUT
          echo "$SANITIZED_OUTPUT" >> $GITHUB_OUTPUT
          echo "SSHFT_OUTPUT_EOF" >> $GITHUB_OUTPUT
          echo "Script executed successfully from path: ${{ inputs.post_script_path }}"
        fi

        # Cleanup
        cleanup_script
        trap - EXIT

    - name: Cleanup SSH files securely
      shell: bash
      if: always()
      run: |
        # Terminate any ssh-agent process
        if [ -n "$SSH_AGENT_PID" ]; then
          ssh-agent -k || true
        fi

        # Securely remove SSH files
        if [ -f "$SSH_KEY_FILE" ]; then
          # Overwrite with zeros before deleting
          dd if=/dev/zero of="$SSH_KEY_FILE" bs=1k count=1 conv=notrunc >/dev/null 2>&1 || true
          rm -f "$SSH_KEY_FILE"
        fi

        # Remove other temporary SSH files
        rm -f "$SSH_CONFIG_FILE"
        rm -f "$SSH_KNOWN_HOSTS"

branding:
  icon: "upload-cloud"
  color: "blue"
